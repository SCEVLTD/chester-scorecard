---
phase: 04-data-import
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/excel-import-parser.ts
  - src/schemas/import-row.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Excel file (.xlsx, .xls, .csv) can be parsed in the browser"
    - "Column headers are detected and mapped to known fields"
    - "Business names from Excel can be matched to database IDs"
    - "Invalid rows are identified with clear error messages"
  artifacts:
    - path: "src/lib/excel-import-parser.ts"
      provides: "Excel parsing with SheetJS, column mapping, business name matching"
      exports: ["parseExcelFile", "mapColumnsToFields", "matchBusinessNames", "COLUMN_ALIASES"]
    - path: "src/schemas/import-row.ts"
      provides: "Zod validation schema for import rows"
      exports: ["importRowSchema", "ImportRow", "ValidatedImportRow"]
  key_links:
    - from: "src/lib/excel-import-parser.ts"
      to: "xlsx library"
      via: "read() and utils.sheet_to_json()"
      pattern: "read\\(|sheet_to_json"
    - from: "src/lib/excel-import-parser.ts"
      to: "src/schemas/import-row.ts"
      via: "zod validation"
      pattern: "importRowSchema\\.safeParse"
---

<objective>
Create the Excel parsing core that transforms Shane's Excel files into validated, database-ready rows.

Purpose: Enable historical data import (sales from 2021, EBITDA from 2025, 2026 targets) without developer intervention. The parser must handle column name variations and map business names to UUIDs.

Output: Excel parser library with column alias detection, row validation, and business name matching. Ready for use by import UI in Plan 02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-import/04-RESEARCH.md

# Existing patterns
@src/lib/excel-mapper.ts (export pattern - now creating import counterpart)
@src/hooks/use-unified-submission.ts (shows data_request + company_submissions pattern)
@src/types/database.types.ts (CompanySubmission shape for target schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create import row schema</name>
  <files>
    - package.json
    - src/schemas/import-row.ts
  </files>
  <action>
Install xlsx (SheetJS) and react-dropzone:

```bash
npm install xlsx react-dropzone
```

Create src/schemas/import-row.ts with Zod validation:

```typescript
import { z } from 'zod'

/**
 * Import row schema - validates parsed Excel rows
 * All financial fields are optional because:
 * - Historical sales data may not have EBITDA
 * - Historical EBITDA data may not have sales
 * - Targets may be annual (divided by 12 later)
 */
export const importRowSchema = z.object({
  // Required: business identification
  businessName: z.string().min(1, 'Business name is required'),

  // Required: time period
  month: z.string().regex(/^\d{4}-\d{2}$/, 'Month must be YYYY-MM format'),

  // Financial actuals (optional - may not have all data)
  revenue: z.coerce.number().optional(),
  grossProfit: z.coerce.number().optional(),
  overheads: z.coerce.number().optional(),
  ebitda: z.coerce.number().optional(),
  totalWages: z.coerce.number().optional(),

  // Financial targets (optional - may not exist for historical)
  revenueTarget: z.coerce.number().optional(),
  grossProfitTarget: z.coerce.number().optional(),
  overheadsTarget: z.coerce.number().optional(),
  ebitdaTarget: z.coerce.number().optional(),

  // Lead KPIs (optional)
  outboundCalls: z.coerce.number().optional(),
  firstOrders: z.coerce.number().optional(),
})

export type ImportRow = z.infer<typeof importRowSchema>

/**
 * Validated row with matched business ID
 */
export interface ValidatedImportRow extends ImportRow {
  businessId: string  // UUID after matching
  isValid: boolean
  errors: string[]
}

/**
 * Parse result summary
 */
export interface ParseResult {
  validRows: ValidatedImportRow[]
  invalidRows: Array<{
    rowNumber: number
    data: Record<string, unknown>
    errors: string[]
  }>
  unmatchedBusinesses: string[]
  detectedColumns: string[]
}
```
  </action>
  <verify>
Run `npm ls xlsx react-dropzone` to confirm packages installed.
TypeScript compiles: `npx tsc --noEmit src/schemas/import-row.ts`
  </verify>
  <done>
xlsx and react-dropzone installed. Import row schema exports importRowSchema, ImportRow, ValidatedImportRow, ParseResult types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Excel parser with column mapping</name>
  <files>
    - src/lib/excel-import-parser.ts
  </files>
  <action>
Create src/lib/excel-import-parser.ts with:

1. **COLUMN_ALIASES** - Maps variations to canonical field names:
   - "business" | "business name" | "company" | "company name" -> businessName
   - "month" | "period" | "date" -> month
   - "sales" | "revenue" | "turnover" -> revenue
   - "sales target" | "revenue target" | "budget sales" -> revenueTarget
   - "gross profit" | "gp" -> grossProfit
   - "gp target" | "gross profit target" -> grossProfitTarget
   - "ebitda" | "net profit" | "ebit" | "profit" -> ebitda
   - "ebitda target" | "net profit target" -> ebitdaTarget
   - "overheads" | "costs" | "operating costs" -> overheads
   - "overheads budget" | "overheads target" | "costs budget" -> overheadsTarget
   - "wages" | "total wages" | "payroll" -> totalWages
   - "outbound calls" | "calls" -> outboundCalls
   - "first orders" | "new accounts" | "new customers" -> firstOrders

2. **parseExcelFile(file: File)** - Main entry point:
   - Use SheetJS read() with { cellDates: true } option
   - Get first worksheet
   - Use utils.sheet_to_json() to get raw rows
   - Return raw rows + detected headers

3. **mapColumnsToFields(rawRows: Record<string, unknown>[], headers: string[])** - Map raw Excel columns to schema fields:
   - Normalize headers (lowercase, trim)
   - Match against COLUMN_ALIASES
   - Transform each row to use canonical field names
   - Handle date format conversion for month field (Excel dates -> YYYY-MM)

4. **normalizeMonth(value: unknown)** - Convert various date formats to YYYY-MM:
   - Date objects -> format with date-fns
   - "Jan 2021" style strings -> parse and format
   - "2021-01" already correct -> pass through
   - Numbers (Excel serial dates) -> convert via SheetJS

5. **matchBusinessNames(rows: ImportRow[], businesses: Array<{id: string, name: string}>)** - Map names to IDs:
   - Build case-insensitive lookup map
   - Normalize names (lowercase, trim, remove "Ltd", "Limited", "Ltd.", "PLC")
   - Return matched rows with businessId + list of unmatched business names

Use date-fns (already installed) for date formatting. Import types from src/schemas/import-row.ts.

**Edge cases to handle:**
- Empty rows (skip)
- Rows missing businessName or month (flag as invalid)
- Multiple sheets (use first sheet only, log warning)
- Numeric values that come as strings (coerce)
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/excel-import-parser.ts`

Create a simple test file and run manually:
```typescript
// Quick manual test - can be deleted after verification
import { parseExcelFile, COLUMN_ALIASES } from './excel-import-parser'
console.log('Column aliases:', Object.keys(COLUMN_ALIASES).length)
```
  </verify>
  <done>
excel-import-parser.ts exports parseExcelFile, mapColumnsToFields, matchBusinessNames, normalizeMonth, COLUMN_ALIASES. Parser handles column variations, date formats, and business name matching.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add import row validation function</name>
  <files>
    - src/lib/excel-import-parser.ts
  </files>
  <action>
Add validateImportRows function to excel-import-parser.ts:

```typescript
/**
 * Validate rows against schema and match business names
 * Returns ParseResult with valid/invalid rows and unmatched businesses
 */
export function validateImportRows(
  mappedRows: Record<string, unknown>[],
  businesses: Array<{ id: string; name: string }>
): ParseResult {
  const validRows: ValidatedImportRow[] = []
  const invalidRows: ParseResult['invalidRows'] = []
  const unmatchedBusinessesSet = new Set<string>()

  // Build business lookup
  const businessMap = buildBusinessLookup(businesses)

  for (let i = 0; i < mappedRows.length; i++) {
    const rawRow = mappedRows[i]
    const rowNumber = i + 2 // +1 for 0-index, +1 for header row

    // Validate with Zod
    const result = importRowSchema.safeParse(rawRow)

    if (!result.success) {
      invalidRows.push({
        rowNumber,
        data: rawRow,
        errors: result.error.errors.map(e => `${e.path.join('.')}: ${e.message}`)
      })
      continue
    }

    const row = result.data

    // Match business name
    const businessId = matchBusinessName(row.businessName, businessMap)

    if (!businessId) {
      unmatchedBusinessesSet.add(row.businessName)
      invalidRows.push({
        rowNumber,
        data: rawRow,
        errors: [`Unknown business: "${row.businessName}"`]
      })
      continue
    }

    validRows.push({
      ...row,
      businessId,
      isValid: true,
      errors: []
    })
  }

  return {
    validRows,
    invalidRows,
    unmatchedBusinesses: Array.from(unmatchedBusinessesSet),
    detectedColumns: [] // Filled by caller
  }
}

// Helper: Build case-insensitive business lookup
function buildBusinessLookup(businesses: Array<{ id: string; name: string }>) {
  const map = new Map<string, string>()
  for (const b of businesses) {
    const normalized = normalizeBusinessName(b.name)
    map.set(normalized, b.id)
  }
  return map
}

// Helper: Normalize business name for matching
function normalizeBusinessName(name: string): string {
  return name
    .toLowerCase()
    .trim()
    .replace(/\s*(ltd\.?|limited|plc|inc\.?|llc)\s*$/i, '')
    .trim()
}

// Helper: Match single business name
function matchBusinessName(name: string, businessMap: Map<string, string>): string | undefined {
  return businessMap.get(normalizeBusinessName(name))
}
```

Also update the exports at the bottom of the file to include validateImportRows.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/lib/excel-import-parser.ts`
  </verify>
  <done>
validateImportRows function added. Full parsing pipeline complete: file -> parse -> map columns -> validate rows -> match businesses -> return ParseResult with valid/invalid separation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependencies installed:**
   ```bash
   npm ls xlsx react-dropzone
   ```

2. **TypeScript compiles:**
   ```bash
   npx tsc --noEmit src/lib/excel-import-parser.ts src/schemas/import-row.ts
   ```

3. **Exports available:**
   - src/schemas/import-row.ts: importRowSchema, ImportRow, ValidatedImportRow, ParseResult
   - src/lib/excel-import-parser.ts: parseExcelFile, mapColumnsToFields, matchBusinessNames, validateImportRows, normalizeMonth, COLUMN_ALIASES
</verification>

<success_criteria>
1. xlsx and react-dropzone packages installed
2. Import row schema validates financial data with optional fields
3. Excel parser handles .xlsx, .xls, .csv file reading
4. Column alias mapping handles variations (Sales/Revenue/Turnover -> revenue)
5. Business name matching normalizes and matches (removes Ltd, case-insensitive)
6. Month normalization handles Excel dates, "Jan 2021" strings, and YYYY-MM
7. Invalid rows collected with specific error messages
8. Unmatched businesses tracked for user notification
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-import/04-01-SUMMARY.md`
</output>
