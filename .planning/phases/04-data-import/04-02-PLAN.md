---
phase: 04-data-import
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/admin/excel-import-dropzone.tsx
  - src/components/admin/import-preview-table.tsx
  - src/components/admin/import-progress.tsx
  - src/hooks/use-excel-import.ts
  - src/pages/admin/import.tsx
  - src/App.tsx
autonomous: false

must_haves:
  truths:
    - "Admin can drag-drop Excel/CSV file to upload"
    - "Preview shows parsed data with validation status before import"
    - "Unmatched business names are highlighted for resolution"
    - "Import creates data_requests and company_submissions for each valid row"
    - "Progress shows success/error counts during import"
    - "Historical data appears in scorecard history after import"
  artifacts:
    - path: "src/components/admin/excel-import-dropzone.tsx"
      provides: "Drag-drop file upload component"
      exports: ["ExcelImportDropzone"]
    - path: "src/components/admin/import-preview-table.tsx"
      provides: "Preview table showing parsed rows with validation"
      exports: ["ImportPreviewTable"]
    - path: "src/components/admin/import-progress.tsx"
      provides: "Import progress and results display"
      exports: ["ImportProgress"]
    - path: "src/hooks/use-excel-import.ts"
      provides: "Import mutation hook with bulk upsert"
      exports: ["useExcelImport"]
    - path: "src/pages/admin/import.tsx"
      provides: "Admin import page at /admin/import"
      exports: ["AdminImportPage"]
  key_links:
    - from: "src/pages/admin/import.tsx"
      to: "src/hooks/use-excel-import.ts"
      via: "useExcelImport hook"
      pattern: "useExcelImport\\("
    - from: "src/hooks/use-excel-import.ts"
      to: "supabase"
      via: "data_requests and company_submissions upsert"
      pattern: "supabase\\.from\\('data_requests'\\)|supabase\\.from\\('company_submissions'\\)"
    - from: "src/components/admin/excel-import-dropzone.tsx"
      to: "src/lib/excel-import-parser.ts"
      via: "parseExcelFile on file drop"
      pattern: "parseExcelFile"
---

<objective>
Build the admin import UI and hook so Chester admins can self-service upload Shane's historical Excel data.

Purpose: Fulfill DATA-04 (self-service upload for Chester admins). Enable historical data visibility in charts without developer intervention. Admin uploads file -> previews parsed data -> confirms import -> data appears in scorecards.

Output: Complete import workflow at /admin/import with dropzone, preview, validation display, and bulk import.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-import/04-RESEARCH.md
@.planning/phases/04-data-import/04-01-SUMMARY.md

# Parser from Plan 01
@src/lib/excel-import-parser.ts
@src/schemas/import-row.ts

# Existing patterns
@src/hooks/use-unified-submission.ts (data_request + company_submissions upsert pattern)
@src/pages/home.tsx (admin page pattern with card layout)
@src/components/auth/protected-route.tsx (role-based access)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create import UI components</name>
  <files>
    - src/components/admin/excel-import-dropzone.tsx
    - src/components/admin/import-preview-table.tsx
    - src/components/admin/import-progress.tsx
  </files>
  <action>
Create src/components/admin/ directory and three components:

**1. excel-import-dropzone.tsx:**
```typescript
import { useDropzone } from 'react-dropzone'
import { Upload, FileSpreadsheet } from 'lucide-react'
import { cn } from '@/lib/utils'

interface Props {
  onFileSelected: (file: File) => void
  isLoading?: boolean
  selectedFile?: File | null
}

export function ExcelImportDropzone({ onFileSelected, isLoading, selectedFile }: Props) {
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: {
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel': ['.xls'],
      'text/csv': ['.csv'],
    },
    maxFiles: 1,
    disabled: isLoading,
    onDrop: ([file]) => file && onFileSelected(file),
  })

  return (
    <div
      {...getRootProps()}
      className={cn(
        'border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors',
        isDragActive ? 'border-primary bg-primary/5' : 'border-muted-foreground/25',
        isLoading && 'opacity-50 cursor-not-allowed'
      )}
    >
      <input {...getInputProps()} />
      {selectedFile ? (
        <>
          <FileSpreadsheet className="mx-auto h-12 w-12 text-green-600" />
          <p className="mt-2 font-medium">{selectedFile.name}</p>
          <p className="text-sm text-muted-foreground">Click or drop to replace</p>
        </>
      ) : (
        <>
          <Upload className="mx-auto h-12 w-12 text-muted-foreground" />
          <p className="mt-2 font-medium">Drag & drop Excel or CSV file</p>
          <p className="text-sm text-muted-foreground">Or click to browse</p>
        </>
      )}
    </div>
  )
}
```

**2. import-preview-table.tsx:**
Display parsed rows in a scrollable table. Show validation status per row. Highlight unmatched businesses in red. Show detected column mappings at top.

```typescript
import type { ParseResult, ValidatedImportRow } from '@/schemas/import-row'
import { Badge } from '@/components/ui/badge'
import { AlertCircle, CheckCircle } from 'lucide-react'

interface Props {
  parseResult: ParseResult
}

export function ImportPreviewTable({ parseResult }: Props) {
  const { validRows, invalidRows, unmatchedBusinesses, detectedColumns } = parseResult

  return (
    <div className="space-y-4">
      {/* Column detection summary */}
      <div className="text-sm">
        <span className="font-medium">Detected columns: </span>
        {detectedColumns.join(', ') || 'None'}
      </div>

      {/* Unmatched businesses warning */}
      {unmatchedBusinesses.length > 0 && (
        <div className="bg-destructive/10 border border-destructive/20 rounded-lg p-3">
          <div className="flex items-center gap-2 text-destructive font-medium">
            <AlertCircle className="h-4 w-4" />
            {unmatchedBusinesses.length} unmatched business name(s)
          </div>
          <ul className="mt-2 text-sm space-y-1">
            {unmatchedBusinesses.map((name) => (
              <li key={name}>- {name}</li>
            ))}
          </ul>
        </div>
      )}

      {/* Summary stats */}
      <div className="flex gap-4 text-sm">
        <Badge variant="outline" className="bg-green-50">
          <CheckCircle className="h-3 w-3 mr-1" />
          {validRows.length} valid
        </Badge>
        <Badge variant="outline" className="bg-red-50">
          <AlertCircle className="h-3 w-3 mr-1" />
          {invalidRows.length} invalid
        </Badge>
      </div>

      {/* Preview table - scrollable */}
      <div className="border rounded-lg overflow-auto max-h-96">
        <table className="w-full text-sm">
          <thead className="bg-muted sticky top-0">
            <tr>
              <th className="p-2 text-left">Row</th>
              <th className="p-2 text-left">Business</th>
              <th className="p-2 text-left">Month</th>
              <th className="p-2 text-right">Revenue</th>
              <th className="p-2 text-right">GP</th>
              <th className="p-2 text-right">EBITDA</th>
              <th className="p-2 text-left">Status</th>
            </tr>
          </thead>
          <tbody>
            {validRows.map((row, i) => (
              <tr key={i} className="border-t">
                <td className="p-2">{i + 2}</td>
                <td className="p-2">{row.businessName}</td>
                <td className="p-2">{row.month}</td>
                <td className="p-2 text-right">{row.revenue?.toLocaleString() ?? '-'}</td>
                <td className="p-2 text-right">{row.grossProfit?.toLocaleString() ?? '-'}</td>
                <td className="p-2 text-right">{row.ebitda?.toLocaleString() ?? '-'}</td>
                <td className="p-2">
                  <Badge variant="outline" className="bg-green-50 text-green-700">Valid</Badge>
                </td>
              </tr>
            ))}
            {invalidRows.map((row, i) => (
              <tr key={`invalid-${i}`} className="border-t bg-red-50/50">
                <td className="p-2">{row.rowNumber}</td>
                <td className="p-2 text-red-700" colSpan={5}>
                  {row.errors.join(', ')}
                </td>
                <td className="p-2">
                  <Badge variant="outline" className="bg-red-50 text-red-700">Invalid</Badge>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

**3. import-progress.tsx:**
Show import progress during execution and final results.

```typescript
import { CheckCircle, XCircle, Loader2 } from 'lucide-react'
import { Progress } from '@/components/ui/progress' // Create if needed, or use simple div

interface Props {
  total: number
  completed: number
  failed: number
  isComplete: boolean
  errors: string[]
}

export function ImportProgress({ total, completed, failed, isComplete, errors }: Props) {
  const progress = total > 0 ? ((completed + failed) / total) * 100 : 0

  return (
    <div className="space-y-4">
      {!isComplete && (
        <div className="flex items-center gap-2">
          <Loader2 className="h-4 w-4 animate-spin" />
          <span>Importing... {completed + failed} of {total}</span>
        </div>
      )}

      <div className="h-2 bg-muted rounded-full overflow-hidden">
        <div
          className="h-full bg-primary transition-all"
          style={{ width: `${progress}%` }}
        />
      </div>

      {isComplete && (
        <div className="space-y-2">
          <div className="flex items-center gap-2 text-green-600">
            <CheckCircle className="h-4 w-4" />
            <span>{completed} rows imported successfully</span>
          </div>
          {failed > 0 && (
            <div className="flex items-center gap-2 text-red-600">
              <XCircle className="h-4 w-4" />
              <span>{failed} rows failed</span>
            </div>
          )}
          {errors.length > 0 && (
            <ul className="text-sm text-red-600 mt-2 space-y-1">
              {errors.slice(0, 10).map((err, i) => (
                <li key={i}>- {err}</li>
              ))}
              {errors.length > 10 && <li>...and {errors.length - 10} more</li>}
            </ul>
          )}
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/components/admin/*.tsx`
  </verify>
  <done>
Three components created: ExcelImportDropzone (file selection), ImportPreviewTable (parsed data display), ImportProgress (import status). All use existing UI components (Badge, etc.) and styling patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create import hook with bulk upsert</name>
  <files>
    - src/hooks/use-excel-import.ts
  </files>
  <action>
Create src/hooks/use-excel-import.ts following the useCreateUnifiedSubmission pattern:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { ValidatedImportRow } from '@/schemas/import-row'
import type { DataRequestInsert, CompanySubmissionInsert } from '@/types/database.types'

interface ImportProgress {
  total: number
  completed: number
  failed: number
  isComplete: boolean
  errors: string[]
}

interface ImportResult {
  successCount: number
  failureCount: number
  errors: string[]
}

/**
 * Hook to import validated rows into database
 * Creates data_requests and company_submissions for each row
 */
export function useExcelImport() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      rows,
      onProgress,
    }: {
      rows: ValidatedImportRow[]
      onProgress?: (progress: ImportProgress) => void
    }): Promise<ImportResult> => {
      const errors: string[] = []
      let completed = 0
      let failed = 0

      for (const row of rows) {
        try {
          // 1. Find or create data_request for business+month
          const { data: existingRequest, error: findError } = await supabase
            .from('data_requests')
            .select('id')
            .eq('business_id', row.businessId)
            .eq('month', row.month)
            .maybeSingle()

          if (findError) throw findError

          let dataRequestId: string

          if (existingRequest) {
            dataRequestId = existingRequest.id
          } else {
            // Create new data_request
            const newRequest: DataRequestInsert = {
              business_id: row.businessId,
              month: row.month,
              token: crypto.randomUUID(),
              status: 'submitted',
              expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
            }

            const { data: created, error: createError } = await supabase
              .from('data_requests')
              .insert(newRequest)
              .select('id')
              .single()

            if (createError) throw createError
            dataRequestId = created.id
          }

          // 2. Build company_submission data
          // For historical import, we only have what's in the Excel
          // Calculate EBITDA if not provided but GP and overheads exist
          const netProfit = row.ebitda ??
            (row.grossProfit !== undefined && row.overheads !== undefined
              ? row.grossProfit - row.overheads
              : 0)
          const netProfitTarget = row.ebitdaTarget ??
            (row.grossProfitTarget !== undefined && row.overheadsTarget !== undefined
              ? row.grossProfitTarget - row.overheadsTarget
              : 0)

          const submission: CompanySubmissionInsert = {
            data_request_id: dataRequestId,
            // Financial actuals
            revenue_actual: row.revenue ?? 0,
            revenue_target: row.revenueTarget ?? 0,
            gross_profit_actual: row.grossProfit ?? 0,
            gross_profit_target: row.grossProfitTarget ?? 0,
            overheads_actual: row.overheads ?? 0,
            overheads_budget: row.overheadsTarget ?? 0,
            net_profit_actual: netProfit,
            net_profit_target: netProfitTarget,
            net_profit_override: row.ebitda !== undefined, // True if EBITDA was explicit
            total_wages: row.totalWages ?? 0,
            productivity_benchmark: 2.5, // Default - can be adjusted later
            // Lead KPIs
            outbound_calls: row.outboundCalls ?? null,
            first_orders: row.firstOrders ?? null,
            // Qualitative - null for historical (no self-assessment)
            leadership: null,
            market_demand: null,
            marketing: null,
            product_strength: null,
            supplier_strength: null,
            sales_execution: null,
            // Commentary
            company_wins: null,
            company_challenges: null,
            company_biggest_opportunity: null,
            company_biggest_risk: null,
            // Metadata
            submitted_by_name: 'Historical Import',
          }

          // 3. Upsert company_submission
          const { error: upsertError } = await supabase
            .from('company_submissions')
            .upsert(submission, { onConflict: 'data_request_id' })

          if (upsertError) throw upsertError

          completed++
        } catch (err) {
          failed++
          const errMsg = err instanceof Error ? err.message : 'Unknown error'
          errors.push(`Row ${row.month} for ${row.businessName}: ${errMsg}`)
        }

        // Report progress
        onProgress?.({
          total: rows.length,
          completed,
          failed,
          isComplete: false,
          errors,
        })
      }

      // Final progress
      onProgress?.({
        total: rows.length,
        completed,
        failed,
        isComplete: true,
        errors,
      })

      return {
        successCount: completed,
        failureCount: failed,
        errors,
      }
    },
    onSuccess: () => {
      // Invalidate all related queries
      queryClient.invalidateQueries({ queryKey: ['company-submissions'] })
      queryClient.invalidateQueries({ queryKey: ['data-requests'] })
      queryClient.invalidateQueries({ queryKey: ['scorecards'] })
    },
  })
}
```

**Key decisions:**
- Upsert with onConflict: 'data_request_id' allows re-running import
- Missing financial values default to 0 (can be updated later)
- EBITDA calculated from GP - Overheads if not provided explicitly
- productivity_benchmark defaults to 2.5 (typical value)
- Qualitative fields null for historical data (no self-assessment)
- submitted_by_name = 'Historical Import' for audit trail
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/hooks/use-excel-import.ts`
  </verify>
  <done>
useExcelImport hook created. Accepts validated rows, creates data_requests, upserts company_submissions, reports progress, handles errors per-row.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create admin import page and add route</name>
  <files>
    - src/pages/admin/import.tsx
    - src/App.tsx
  </files>
  <action>
**1. Create src/pages/admin/import.tsx:**

```typescript
import { useState, useCallback } from 'react'
import { toast } from 'sonner'
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { ArrowLeft, Upload } from 'lucide-react'
import { useLocation } from 'wouter'

import { ExcelImportDropzone } from '@/components/admin/excel-import-dropzone'
import { ImportPreviewTable } from '@/components/admin/import-preview-table'
import { ImportProgress } from '@/components/admin/import-progress'

import { parseExcelFile, mapColumnsToFields, validateImportRows } from '@/lib/excel-import-parser'
import { useExcelImport } from '@/hooks/use-excel-import'
import { useBusinesses } from '@/hooks/use-businesses'
import type { ParseResult } from '@/schemas/import-row'

type ImportState = 'idle' | 'parsing' | 'preview' | 'importing' | 'complete'

export function AdminImportPage() {
  const [, navigate] = useLocation()
  const [state, setState] = useState<ImportState>('idle')
  const [selectedFile, setSelectedFile] = useState<File | null>(null)
  const [parseResult, setParseResult] = useState<ParseResult | null>(null)
  const [progress, setProgress] = useState({
    total: 0,
    completed: 0,
    failed: 0,
    isComplete: false,
    errors: [] as string[],
  })

  const { data: businesses } = useBusinesses()
  const importMutation = useExcelImport()

  const handleFileSelected = useCallback(async (file: File) => {
    setSelectedFile(file)
    setState('parsing')

    try {
      // Parse Excel file
      const { rows: rawRows, headers } = await parseExcelFile(file)

      if (rawRows.length === 0) {
        toast.error('File is empty or has no data rows')
        setState('idle')
        return
      }

      // Map columns to schema fields
      const mappedRows = mapColumnsToFields(rawRows, headers)

      // Validate and match business names
      const result = validateImportRows(
        mappedRows,
        businesses?.map(b => ({ id: b.id, name: b.name })) ?? []
      )
      result.detectedColumns = headers

      setParseResult(result)
      setState('preview')

      if (result.validRows.length === 0) {
        toast.warning('No valid rows found. Check the preview for errors.')
      } else {
        toast.success(`Parsed ${result.validRows.length} valid rows`)
      }
    } catch (err) {
      console.error('Parse error:', err)
      toast.error('Failed to parse file: ' + (err instanceof Error ? err.message : 'Unknown error'))
      setState('idle')
    }
  }, [businesses])

  const handleImport = useCallback(async () => {
    if (!parseResult || parseResult.validRows.length === 0) return

    setState('importing')
    setProgress({
      total: parseResult.validRows.length,
      completed: 0,
      failed: 0,
      isComplete: false,
      errors: [],
    })

    try {
      const result = await importMutation.mutateAsync({
        rows: parseResult.validRows,
        onProgress: setProgress,
      })

      setState('complete')

      if (result.failureCount === 0) {
        toast.success(`Successfully imported ${result.successCount} rows`)
      } else {
        toast.warning(`Imported ${result.successCount} rows, ${result.failureCount} failed`)
      }
    } catch (err) {
      console.error('Import error:', err)
      toast.error('Import failed: ' + (err instanceof Error ? err.message : 'Unknown error'))
      setState('preview')
    }
  }, [parseResult, importMutation])

  const handleReset = () => {
    setSelectedFile(null)
    setParseResult(null)
    setProgress({ total: 0, completed: 0, failed: 0, isComplete: false, errors: [] })
    setState('idle')
  }

  return (
    <div className="min-h-screen bg-background p-4 md:p-8">
      <div className="mx-auto max-w-4xl">
        <Button
          variant="ghost"
          className="mb-4"
          onClick={() => navigate('/')}
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Dashboard
        </Button>

        <Card>
          <CardHeader>
            <CardTitle>Import Historical Data</CardTitle>
            <CardDescription>
              Upload Excel or CSV files containing historical sales, EBITDA, or target data.
              The system will match business names and import the data.
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* File dropzone - always visible for reference */}
            <ExcelImportDropzone
              onFileSelected={handleFileSelected}
              isLoading={state === 'parsing' || state === 'importing'}
              selectedFile={selectedFile}
            />

            {/* Preview */}
            {state === 'preview' && parseResult && (
              <>
                <ImportPreviewTable parseResult={parseResult} />

                <div className="flex gap-2 justify-end">
                  <Button variant="outline" onClick={handleReset}>
                    Cancel
                  </Button>
                  <Button
                    onClick={handleImport}
                    disabled={parseResult.validRows.length === 0}
                  >
                    <Upload className="mr-2 h-4 w-4" />
                    Import {parseResult.validRows.length} Rows
                  </Button>
                </div>
              </>
            )}

            {/* Progress during import */}
            {(state === 'importing' || state === 'complete') && (
              <ImportProgress {...progress} />
            )}

            {/* Complete - offer reset */}
            {state === 'complete' && (
              <div className="flex gap-2 justify-end">
                <Button variant="outline" onClick={handleReset}>
                  Import Another File
                </Button>
                <Button onClick={() => navigate('/')}>
                  Back to Dashboard
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
```

**2. Update src/App.tsx to add the route:**

Add import at top:
```typescript
import { AdminImportPage } from '@/pages/admin/import'
```

Add route inside Router, protected for admins:
```tsx
<Route path="/admin/import">
  <ProtectedRoute requireAdmin>
    <AdminImportPage />
  </ProtectedRoute>
</Route>
```

Also add a link to the import page from the home page for admins. In src/pages/home.tsx, add a button near the Portfolio button:

```tsx
<Button
  variant="outline"
  size="sm"
  onClick={() => navigate('/admin/import')}
>
  <Upload className="mr-2 h-4 w-4" />
  Import Data
</Button>
```

Import Upload icon from lucide-react at top of home.tsx.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/pages/admin/import.tsx`
Run dev server: `npm run dev`
Navigate to /admin/import (as admin) - page loads
  </verify>
  <done>
Admin import page created at /admin/import. Route protected for admin users. Link added to home page. Full workflow: select file -> preview parsed data -> confirm import -> see progress -> complete.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete data import workflow:
1. Admin-only import page at /admin/import
2. Drag-drop file upload for Excel/CSV
3. Column detection and alias mapping
4. Business name matching with error display
5. Preview table showing valid/invalid rows
6. Bulk import with progress tracking
7. Data visible in scorecard history
  </what-built>
  <how-to-verify>
1. Log in as Chester admin user
2. Navigate to /admin/import (or click "Import Data" on home page)
3. Prepare a test Excel file with columns:
   - "Business Name" or "Company"
   - "Month" (format: 2025-01 or Jan 2025)
   - "Revenue" or "Sales"
   - "EBITDA" or "Net Profit" (optional)
4. Drag-drop or click to upload the file
5. Verify:
   - Detected columns shown correctly
   - Business names matched to existing businesses
   - Unmatched business names highlighted
   - Valid/invalid row counts correct
6. Click "Import X Rows"
7. Watch progress bar complete
8. Navigate to a business scorecard
9. Verify imported data appears in history
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Components exist and compile:**
   ```bash
   ls src/components/admin/
   npx tsc --noEmit src/components/admin/*.tsx
   ```

2. **Hook exists and compiles:**
   ```bash
   npx tsc --noEmit src/hooks/use-excel-import.ts
   ```

3. **Page accessible:**
   - Run dev server: `npm run dev`
   - Log in as admin
   - Navigate to /admin/import
   - Page renders without errors

4. **Route protected:**
   - Log out
   - Navigate to /admin/import directly
   - Redirected to login (or unauthorized)

5. **Import workflow:**
   - Upload test Excel file
   - Preview shows parsed data
   - Import creates database records
   - Data visible in business history
</verification>

<success_criteria>
1. Admin can access /admin/import (non-admins blocked)
2. Dropzone accepts .xlsx, .xls, .csv files
3. Parser detects column variations (Sales/Revenue/Turnover)
4. Business names matched to database IDs
5. Unmatched businesses clearly displayed
6. Preview shows all rows with validation status
7. Import button only enabled when valid rows exist
8. Progress bar updates during import
9. Success/failure counts accurate
10. Imported data appears in scorecard history
11. Re-running import updates (not duplicates) existing months
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-import/04-02-SUMMARY.md`
</output>
