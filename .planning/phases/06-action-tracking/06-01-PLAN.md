---
phase: 06-action-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260202_add_actions.sql
  - src/types/database.types.ts
  - src/schemas/action.ts
  - src/hooks/use-actions.ts
autonomous: true

must_haves:
  truths:
    - "Actions table exists with proper schema"
    - "RLS policies restrict business users to own actions"
    - "TypeScript types support action CRUD operations"
    - "Hooks can create, query, and complete actions"
  artifacts:
    - path: "supabase/migrations/20260202_add_actions.sql"
      provides: "Actions table with RLS policies"
      contains: "CREATE TABLE"
    - path: "src/types/database.types.ts"
      provides: "Action type exports"
      contains: "Action ="
    - path: "src/schemas/action.ts"
      provides: "Zod validation schema"
      exports: ["actionSchema", "ActionFormData"]
    - path: "src/hooks/use-actions.ts"
      provides: "TanStack Query hooks"
      exports: ["useCreateAction", "useBusinessPendingActions", "useCompleteAction"]
  key_links:
    - from: "src/hooks/use-actions.ts"
      to: "supabase.from('actions')"
      via: "Supabase client queries"
      pattern: "from\\('actions'\\)"
    - from: "src/schemas/action.ts"
      to: "src/types/database.types.ts"
      via: "Type alignment"
      pattern: "ActionFormData"
---

<objective>
Create the database schema, TypeScript types, and TanStack Query hooks for action tracking.

Purpose: Establish the foundation for capturing and managing actions from Friday meetings.
Output: Migration file, types, validation schema, and CRUD hooks ready for UI consumption.
</objective>

<execution_context>
@C:\Users\conta\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\conta\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-action-tracking/06-RESEARCH.md

# Existing patterns to follow
@src/hooks/use-data-requests.ts
@src/types/database.types.ts
@supabase/migrations/20260202_add_rls_policies.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create actions database migration with RLS</name>
  <files>supabase/migrations/20260202_add_actions.sql</files>
  <action>
Create migration file with:

1. Actions table:
```sql
CREATE TABLE IF NOT EXISTS actions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id uuid NOT NULL REFERENCES businesses(id) ON DELETE CASCADE,
  description text NOT NULL,
  owner text NOT NULL,
  due_date date NOT NULL,
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'complete')),
  created_at timestamptz DEFAULT now(),
  completed_at timestamptz,
  created_by text
);
```

2. Performance indexes:
```sql
CREATE INDEX idx_actions_business_status ON actions(business_id, status);
CREATE INDEX idx_actions_due_date ON actions(due_date) WHERE status = 'pending';
```

3. Enable RLS immediately after table creation:
```sql
ALTER TABLE actions ENABLE ROW LEVEL SECURITY;
```

4. RLS policies following existing pattern (use public.is_admin() and public.get_my_business_id()):
- Admin can SELECT/INSERT/UPDATE/DELETE all
- Business user can SELECT own (business_id = public.get_my_business_id())

Do NOT forget to enable RLS - this is a common pitfall (see RESEARCH.md).
  </action>
  <verify>Migration file exists and contains CREATE TABLE, ENABLE ROW LEVEL SECURITY, and all 5 policies</verify>
  <done>Actions table schema ready for deployment with proper RLS isolation</done>
</task>

<task type="auto">
  <name>Task 2: Add Action types and validation schema</name>
  <files>src/types/database.types.ts, src/schemas/action.ts</files>
  <action>
1. In src/types/database.types.ts, add to Database interface:

```typescript
// In Tables section:
actions: {
  Row: {
    id: string
    business_id: string
    description: string
    owner: string
    due_date: string
    status: 'pending' | 'complete'
    created_at: string
    completed_at: string | null
    created_by: string | null
  }
  Insert: {
    id?: string
    business_id: string
    description: string
    owner: string
    due_date: string
    status?: 'pending' | 'complete'
    created_at?: string
    completed_at?: string | null
    created_by?: string | null
  }
  Update: {
    id?: string
    business_id?: string
    description?: string
    owner?: string
    due_date?: string
    status?: 'pending' | 'complete'
    created_at?: string
    completed_at?: string | null
    created_by?: string | null
  }
  Relationships: [
    {
      foreignKeyName: 'actions_business_id_fkey'
      columns: ['business_id']
      isOneToOne: false
      referencedRelation: 'businesses'
      referencedColumns: ['id']
    }
  ]
}
```

2. Add type exports at bottom:
```typescript
export type Action = Database['public']['Tables']['actions']['Row']
export type ActionInsert = Database['public']['Tables']['actions']['Insert']
export type ActionUpdate = Database['public']['Tables']['actions']['Update']
```

3. Create src/schemas/action.ts:
```typescript
import { z } from 'zod'

export const actionSchema = z.object({
  description: z.string().trim().min(1, 'Action description is required'),
  owner: z.string().trim().min(1, 'Owner is required'),
  due_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Must be a valid date'),
})

export type ActionFormData = z.infer<typeof actionSchema>
```
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Action types available for hooks and components</done>
</task>

<task type="auto">
  <name>Task 3: Create TanStack Query hooks for actions</name>
  <files>src/hooks/use-actions.ts</files>
  <action>
Create src/hooks/use-actions.ts following the pattern from use-data-requests.ts:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import type { Action, ActionInsert } from '@/types/database.types'

/**
 * Create a new action for a business
 */
export function useCreateAction() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: Omit<ActionInsert, 'id' | 'created_at' | 'completed_at' | 'status'>) => {
      const { data: result, error } = await supabase
        .from('actions')
        .insert(data)
        .select()
        .single()

      if (error) throw error
      return result as Action
    },
    onSuccess: (data) => {
      // Invalidate business-specific and global queries
      queryClient.invalidateQueries({ queryKey: ['actions', data.business_id] })
      queryClient.invalidateQueries({ queryKey: ['actions', 'pending'] })
    },
  })
}

/**
 * Get pending actions for a specific business
 */
export function useBusinessPendingActions(businessId: string) {
  return useQuery({
    queryKey: ['actions', businessId, 'pending'],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('actions')
        .select('*')
        .eq('business_id', businessId)
        .eq('status', 'pending')
        .order('due_date', { ascending: true })

      if (error) throw error
      return data as Action[]
    },
    enabled: !!businessId,
  })
}

/**
 * Get count of pending actions for dashboard badge
 */
export function usePendingActionsCount(businessId?: string) {
  return useQuery({
    queryKey: businessId ? ['actions', businessId, 'count'] : ['actions', 'pending', 'count'],
    queryFn: async () => {
      let query = supabase
        .from('actions')
        .select('id', { count: 'exact', head: true })
        .eq('status', 'pending')

      if (businessId) {
        query = query.eq('business_id', businessId)
      }

      const { count, error } = await query

      if (error) throw error
      return count ?? 0
    },
    enabled: businessId === undefined || !!businessId,
  })
}

/**
 * Mark an action as complete
 */
export function useCompleteAction() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (actionId: string) => {
      const { data, error } = await supabase
        .from('actions')
        .update({
          status: 'complete',
          completed_at: new Date().toISOString(),
        })
        .eq('id', actionId)
        .select()
        .single()

      if (error) throw error
      return data as Action
    },
    onSuccess: (data) => {
      // Invalidate all action queries
      queryClient.invalidateQueries({ queryKey: ['actions', data.business_id] })
      queryClient.invalidateQueries({ queryKey: ['actions', 'pending'] })
    },
  })
}
```

Key patterns followed:
- Cache invalidation on mutations (prevents stale data)
- enabled flag for conditional queries
- Type casting from Supabase responses
- Error throwing for proper error handling
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>All hooks ready for UI consumption: create, query pending, count, and complete</done>
</task>

</tasks>

<verification>
1. Migration file exists at supabase/migrations/20260202_add_actions.sql
2. Migration contains:
   - CREATE TABLE actions with all columns
   - ALTER TABLE actions ENABLE ROW LEVEL SECURITY
   - 5 RLS policies (4 admin + 1 business user)
   - 2 indexes for performance
3. src/types/database.types.ts contains Action, ActionInsert, ActionUpdate exports
4. src/schemas/action.ts exports actionSchema and ActionFormData
5. src/hooks/use-actions.ts exports 4 hooks
6. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Actions table migration ready for deployment
- RLS policies follow existing pattern (admin full access, business scoped)
- TypeScript types align with database schema
- All 4 hooks compile and follow codebase patterns
- No new dependencies introduced
</success_criteria>

<output>
After completion, create `.planning/phases/06-action-tracking/06-01-SUMMARY.md`
</output>
