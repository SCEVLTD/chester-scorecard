---
phase: 05-reporting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/portfolio.tsx
  - src/hooks/use-portfolio-summary.ts
  - supabase/functions/generate-meeting-summary/index.ts
  - src/schemas/meeting-summary.ts
  - src/hooks/use-meeting-summary.ts
  - src/components/meeting-summary-card.tsx
autonomous: true

must_haves:
  truths:
    - "Portfolio view shows all businesses without revealing individual data"
    - "Heatmap can filter by month to show historical scores"
    - "Meeting prep summary generates aggregated insights"
    - "Meeting summary highlights common themes, not individual businesses"
  artifacts:
    - path: "src/pages/portfolio.tsx"
      provides: "Portfolio dashboard with month filter"
      contains: "selectedMonth"
    - path: "supabase/functions/generate-meeting-summary/index.ts"
      provides: "Edge Function for meeting prep AI"
      contains: "generate-meeting-summary"
    - path: "src/schemas/meeting-summary.ts"
      provides: "Zod schema for meeting summary validation"
      contains: "meetingSummarySchema"
    - path: "src/components/meeting-summary-card.tsx"
      provides: "Display component for meeting summary"
      contains: "MeetingSummaryCard"
  key_links:
    - from: "src/pages/portfolio.tsx"
      to: "src/hooks/use-portfolio-summary.ts"
      via: "hook with month param"
      pattern: "usePortfolioSummary.*month"
    - from: "src/pages/portfolio.tsx"
      to: "src/hooks/use-meeting-summary.ts"
      via: "hook import"
      pattern: "useGenerateMeetingSummary"
    - from: "src/hooks/use-meeting-summary.ts"
      to: "supabase/functions/generate-meeting-summary"
      via: "Edge Function invocation"
      pattern: "supabase.functions.invoke.*generate-meeting-summary"
---

<objective>
Add month selection to portfolio heatmap and create meeting prep AI summary that aggregates portfolio insights for Friday meetings without identifying individual businesses.

Purpose: Chester admins need to view historical performance (not just latest month) and prepare for meetings with aggregated talking points that maintain confidentiality.

Output: Enhanced portfolio page with month filter and meeting prep AI summary.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-reporting/05-RESEARCH.md

# Existing infrastructure
@src/pages/portfolio.tsx
@src/hooks/use-portfolio-summary.ts
@src/components/portfolio/portfolio-heatmap.tsx
@src/lib/portfolio-aggregator.ts
@src/schemas/portfolio-analysis.ts
@supabase/functions/generate-portfolio-analysis/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add month filter to portfolio heatmap</name>
  <files>src/pages/portfolio.tsx, src/hooks/use-portfolio-summary.ts</files>
  <action>
**1. Update `use-portfolio-summary.ts` to accept optional month parameter:**

```typescript
export function usePortfolioSummary(month?: string) {
  return useQuery({
    queryKey: ['portfolio', 'summary', month],
    queryFn: async (): Promise<PortfolioSummary[]> => {
      // Existing code, but filter scorecards by month if provided
      const scorecardQuery = supabase
        .from('scorecards')
        .select('business_id, total_score, rag_status, month')
        .order('month', { ascending: false })

      if (month) {
        scorecardQuery.eq('month', month)
      }

      const { data: scorecards, error } = await scorecardQuery
      // ... rest of existing logic
    },
  })
}
```

**2. Update `portfolio.tsx` to add month selector:**

Add state and UI for month selection:
```typescript
const [selectedMonth, setSelectedMonth] = useState<string | undefined>(undefined)

// Pass to hook
const { data: portfolio, isLoading } = usePortfolioSummary(selectedMonth)
```

Add Select dropdown above the Tabs component:
- Label: "Filter by month"
- Options: Last 12 months (generated like scorecard page)
- Plus "Latest" option that clears filter (undefined)
- Use existing Select component from @/components/ui/select

**3. Update heatmap data query to use month filter:**

The existing query in portfolio.tsx fetches latest scorecards. Modify to:
- If `selectedMonth` set: fetch scorecards for that specific month
- If `selectedMonth` undefined: keep existing "latest per business" logic

Use this pattern:
```typescript
const { data: latestScorecards } = useQuery({
  queryKey: ['scorecards', 'for-heatmap', selectedMonth],
  queryFn: async () => {
    const query = supabase.from('scorecards').select('*')

    if (selectedMonth) {
      // Specific month
      const { data, error } = await query.eq('month', selectedMonth)
      if (error) throw error
      const byBusiness = new Map<string, Scorecard>()
      for (const sc of data as Scorecard[]) {
        byBusiness.set(sc.business_id, sc)
      }
      return byBusiness
    } else {
      // Latest per business (existing logic)
      const { data, error } = await query.order('month', { ascending: false })
      // ... existing grouping logic
    }
  },
})
```

Do NOT change the heatmap component itself - it receives data via props.
  </action>
  <verify>
Navigate to portfolio page, verify month selector appears and:
1. Selecting a specific month shows only that month's data
2. Selecting "Latest" shows most recent scorecard per business
3. Heatmap updates when month changes
```bash
npm run dev
# Visit http://localhost:5173/portfolio
```
  </verify>
  <done>
Month filter works on portfolio page. REPORT-06 (heat map by month) satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create meeting summary Edge Function</name>
  <files>supabase/functions/generate-meeting-summary/index.ts, src/schemas/meeting-summary.ts</files>
  <action>
**1. Create Zod schema for meeting summary (`src/schemas/meeting-summary.ts`):**

```typescript
import { z } from 'zod'

export const meetingSummarySchema = z.object({
  /** Aggregated wins across portfolio (3-5 items) */
  aggregatedWins: z.array(z.string()),
  /** Common challenges faced (3-5 items) */
  commonChallenges: z.array(z.string()),
  /** Discussion points for meeting (5-7 items) */
  discussionPoints: z.array(z.string()),
  /** Recommended group actions (3-5 items) */
  groupActions: z.array(z.string()),
  /** Portfolio health summary (2-3 sentences) */
  healthSummary: z.string(),
  /** ISO timestamp */
  generatedAt: z.string(),
  /** Model used */
  modelUsed: z.string(),
})

export type MeetingSummary = z.infer<typeof meetingSummarySchema>

export function parseMeetingSummary(data: unknown): MeetingSummary {
  const result = meetingSummarySchema.safeParse(data)
  if (result.success) return result.data
  console.error('[Meeting Summary] Validation failed:', result.error.format())
  throw new Error('Meeting summary response had unexpected format.')
}
```

**2. Create Edge Function (`supabase/functions/generate-meeting-summary/index.ts`):**

Copy structure from existing `generate-portfolio-analysis/index.ts` but with different prompt:

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import Anthropic from 'npm:@anthropic-ai/sdk@0.24.0'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { aggregatedData } = await req.json()

    const anthropic = new Anthropic({
      apiKey: Deno.env.get('ANTHROPIC_API_KEY')!,
    })

    const prompt = `You are preparing a meeting summary for the Chester Brethren Business Group Friday meeting.

IMPORTANT: This summary must NOT identify individual businesses. Focus on patterns and themes across the portfolio.

Portfolio data (aggregated, anonymized):
${JSON.stringify(aggregatedData, null, 2)}

Generate a meeting prep summary with:

1. **aggregatedWins** (3-5 items): Common positive outcomes across multiple businesses. Use phrases like "Several businesses reported..." or "A majority of companies..."

2. **commonChallenges** (3-5 items): Shared difficulties. Never name specific businesses.

3. **discussionPoints** (5-7 items): Topics worth discussing as a group. Frame as "How are members handling..." or "What strategies work for..."

4. **groupActions** (3-5 items): Collective actions the group could take. Focus on peer learning opportunities.

5. **healthSummary** (2-3 sentences): Overall portfolio health assessment. Use aggregate stats only.

Respond ONLY with valid JSON matching this structure:
{
  "aggregatedWins": ["string", ...],
  "commonChallenges": ["string", ...],
  "discussionPoints": ["string", ...],
  "groupActions": ["string", ...],
  "healthSummary": "string",
  "generatedAt": "ISO timestamp",
  "modelUsed": "claude-sonnet-4-20250514"
}`

    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1500,
      messages: [{ role: 'user', content: prompt }],
    })

    const content = message.content[0]
    if (content.type !== 'text') {
      throw new Error('Unexpected response type')
    }

    const parsed = JSON.parse(content.text)
    parsed.generatedAt = new Date().toISOString()
    parsed.modelUsed = 'claude-sonnet-4-20250514'

    return new Response(JSON.stringify(parsed), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    })
  }
})
```

Note: Use existing portfolio aggregator pattern - client aggregates data before sending to Edge Function to minimize tokens and protect individual data.
  </action>
  <verify>
Deploy Edge Function and verify it responds:
```bash
cd supabase
npx supabase functions deploy generate-meeting-summary
# Or test locally: npx supabase functions serve
```
  </verify>
  <done>
Edge Function deployed and returns meeting summary JSON matching schema.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create meeting summary UI and integrate</name>
  <files>src/hooks/use-meeting-summary.ts, src/components/meeting-summary-card.tsx, src/pages/portfolio.tsx</files>
  <action>
**1. Create hook (`src/hooks/use-meeting-summary.ts`):**

```typescript
import { useMutation } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'
import { parseMeetingSummary, type MeetingSummary } from '@/schemas/meeting-summary'
import type { PortfolioAggregate } from '@/lib/portfolio-aggregator'

interface GenerateMeetingSummaryParams {
  aggregatedData: PortfolioAggregate
}

export function useGenerateMeetingSummary() {
  return useMutation({
    mutationFn: async ({ aggregatedData }: GenerateMeetingSummaryParams): Promise<MeetingSummary> => {
      const { data, error } = await supabase.functions.invoke('generate-meeting-summary', {
        body: { aggregatedData },
      })
      if (error) throw new Error(error.message || 'Failed to generate meeting summary')
      return parseMeetingSummary(data)
    },
  })
}
```

**2. Create display component (`src/components/meeting-summary-card.tsx`):**

```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { FileText, Trophy, AlertCircle, MessageSquare, Users } from 'lucide-react'
import type { MeetingSummary } from '@/schemas/meeting-summary'

interface MeetingSummaryCardProps {
  summary: MeetingSummary
}

export function MeetingSummaryCard({ summary }: MeetingSummaryCardProps) {
  const formattedDate = new Date(summary.generatedAt).toLocaleDateString('en-GB', {
    day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit',
  })

  return (
    <Card className="border-blue-200 bg-blue-50/50">
      <CardHeader className="pb-4">
        <CardTitle className="flex items-center gap-2 text-blue-700">
          <FileText className="h-5 w-5" />
          Meeting Prep Summary
          <span className="ml-auto text-sm font-normal text-muted-foreground">{formattedDate}</span>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Health Summary */}
        <section>
          <h3 className="text-base font-semibold mb-2">Portfolio Health</h3>
          <p className="text-sm text-muted-foreground">{summary.healthSummary}</p>
        </section>

        {/* Aggregated Wins */}
        <section>
          <h3 className="text-base font-semibold mb-2 flex items-center gap-2">
            <Trophy className="h-4 w-4 text-green-600" />
            Wins Across Portfolio
          </h3>
          <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
            {summary.aggregatedWins.map((win, i) => <li key={i}>{win}</li>)}
          </ul>
        </section>

        {/* Common Challenges */}
        <section>
          <h3 className="text-base font-semibold mb-2 flex items-center gap-2">
            <AlertCircle className="h-4 w-4 text-amber-600" />
            Common Challenges
          </h3>
          <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
            {summary.commonChallenges.map((c, i) => <li key={i}>{c}</li>)}
          </ul>
        </section>

        {/* Discussion Points */}
        <section>
          <h3 className="text-base font-semibold mb-2 flex items-center gap-2">
            <MessageSquare className="h-4 w-4 text-blue-600" />
            Discussion Points
          </h3>
          <ol className="list-decimal list-inside space-y-1 text-sm text-muted-foreground">
            {summary.discussionPoints.map((p, i) => <li key={i}>{p}</li>)}
          </ol>
        </section>

        {/* Group Actions */}
        <section>
          <h3 className="text-base font-semibold mb-2 flex items-center gap-2">
            <Users className="h-4 w-4 text-purple-600" />
            Suggested Group Actions
          </h3>
          <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
            {summary.groupActions.map((a, i) => <li key={i}>{a}</li>)}
          </ul>
        </section>
      </CardContent>
    </Card>
  )
}
```

**3. Integrate into portfolio page (`src/pages/portfolio.tsx`):**

Add meeting summary button and display:

```typescript
import { useGenerateMeetingSummary } from '@/hooks/use-meeting-summary'
import { MeetingSummaryCard } from '@/components/meeting-summary-card'
import { aggregatePortfolio } from '@/lib/portfolio-aggregator'
import type { MeetingSummary } from '@/schemas/meeting-summary'

// In component:
const [meetingSummary, setMeetingSummary] = useState<MeetingSummary | null>(null)
const generateMeetingSummary = useGenerateMeetingSummary()

const handleGenerateMeetingSummary = async () => {
  if (!portfolio || !latestScorecards) return
  try {
    const aggregatedData = aggregatePortfolio(portfolio, latestScorecards)
    const result = await generateMeetingSummary.mutateAsync({ aggregatedData })
    setMeetingSummary(result)
    toast.success('Meeting summary generated')
  } catch (error) {
    toast.error(error instanceof Error ? error.message : 'Failed to generate summary')
  }
}

// Add button next to existing "Generate AI Analysis" button:
<Button
  variant="outline"
  onClick={handleGenerateMeetingSummary}
  disabled={generateMeetingSummary.isPending || !portfolio?.length}
>
  {generateMeetingSummary.isPending ? (
    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
  ) : (
    <FileText className="h-4 w-4 mr-2" />
  )}
  Meeting Prep
</Button>

// Display below existing analysis:
{meetingSummary && (
  <div className="mb-6">
    <div className="flex justify-end mb-2">
      <Button variant="ghost" size="sm" onClick={() => setMeetingSummary(null)}>
        <X className="h-4 w-4 mr-1" /> Clear
      </Button>
    </div>
    <MeetingSummaryCard summary={meetingSummary} />
  </div>
)}
```

Key: Use existing `aggregatePortfolio` function to prepare anonymized data before sending to Edge Function.
  </action>
  <verify>
Navigate to portfolio page and test:
1. Click "Meeting Prep" button
2. Summary generates (5-15 seconds)
3. Summary shows aggregated insights without naming individual businesses
```bash
npm run dev
# Visit http://localhost:5173/portfolio
# Click "Meeting Prep" button
```
  </verify>
  <done>
Meeting prep summary generates and displays aggregated insights. REPORT-03 (aggregated portfolio summary) and REPORT-04 (meeting prep AI summary) satisfied.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **REPORT-03 (Aggregated portfolio summary):**
   - Portfolio view shows all businesses
   - Business names visible to Chester admins
   - AI analysis focuses on patterns, not individual details

2. **REPORT-04 (Meeting prep AI summary):**
   - Click "Meeting Prep" button
   - Summary generates within 10 seconds
   - Content shows: Wins, Challenges, Discussion Points, Group Actions
   - No individual business names in the aggregated sections

3. **REPORT-06 (Heat map by month):**
   - Month selector visible above heatmap
   - Selecting different month changes displayed data
   - "Latest" option shows most recent per business

```bash
npm run dev
# Full manual test at http://localhost:5173/portfolio
```
</verification>

<success_criteria>
- [ ] Month selector visible on portfolio page
- [ ] Selecting month filters heatmap data
- [ ] "Meeting Prep" button visible
- [ ] Meeting summary generates successfully
- [ ] Meeting summary shows aggregated wins/challenges
- [ ] No individual business names in meeting summary content
- [ ] Edge Function deployed and working
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-reporting/05-02-SUMMARY.md`
</output>
