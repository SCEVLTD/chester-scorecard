---
phase: 02-authentication
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/App.tsx
  - src/components/auth/protected-route.tsx
  - src/pages/unauthorized.tsx
  - supabase/migrations/20260202_add_rls_policies.sql
autonomous: false
estimated_complexity: medium

must_haves:
  truths:
    - "Unauthenticated users are redirected to /login"
    - "Business users can only access their own business routes"
    - "Admins can access all routes and see all data"
    - "RLS policies enforce data isolation at database level"
    - "Logout clears session and redirects to login"
  artifacts:
    - path: "src/App.tsx"
      provides: "Route structure with auth protection"
      contains: "AuthProvider"
    - path: "src/components/auth/protected-route.tsx"
      provides: "Route guard component"
      exports: ["ProtectedRoute"]
    - path: "src/pages/unauthorized.tsx"
      provides: "403 unauthorized page"
      min_lines: 15
    - path: "supabase/migrations/20260202_add_rls_policies.sql"
      provides: "Row Level Security policies for all tables"
      contains: "CREATE POLICY"
  key_links:
    - from: "src/App.tsx"
      to: "src/contexts/auth-context.tsx"
      via: "AuthProvider wrapper"
      pattern: "<AuthProvider>"
    - from: "src/components/auth/protected-route.tsx"
      to: "src/contexts/auth-context.tsx"
      via: "useAuth hook"
      pattern: "useAuth\\(\\)"
    - from: "RLS policies"
      to: "auth.is_admin(), auth.business_id()"
      via: "helper functions"
      pattern: "auth\\.is_admin\\(\\)|auth\\.business_id\\(\\)"
---

<objective>
Wire up route protection and Row Level Security policies to enforce authentication and authorization.

Purpose: Complete the auth system - protect routes in React and data at database level.
Output: Working login flow with role-based access to routes and data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication/02-RESEARCH.md
@.planning/phases/02-authentication/02-01-SUMMARY.md
@.planning/phases/02-authentication/02-02-SUMMARY.md
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProtectedRoute component and unauthorized page</name>
  <files>src/components/auth/protected-route.tsx, src/pages/unauthorized.tsx</files>
  <action>
**Create `src/components/auth/protected-route.tsx`:**

Route wrapper component with props:
```typescript
interface ProtectedRouteProps {
  children: ReactNode
  requiredRole?: 'admin' | 'business_user'
  allowedBusinessId?: string  // For business-specific routes
}
```

Logic:
1. If `isLoading`: return loading spinner/text
2. If no `session`: redirect to `/login` using wouter's `<Redirect>`
3. If `requiredRole === 'admin'` and `userRole !== 'admin'`: redirect to `/unauthorized`
4. If `allowedBusinessId` provided and user is NOT admin and `businessId !== allowedBusinessId`: redirect to `/unauthorized`
5. Otherwise: render `children`

Key implementation:
```typescript
import { Redirect } from 'wouter'
import { useAuth } from '@/contexts/auth-context'

export function ProtectedRoute({ children, requiredRole, allowedBusinessId }: ProtectedRouteProps) {
  const { session, userRole, businessId, isLoading } = useAuth()

  if (isLoading) return <div className="p-8 text-center">Loading...</div>
  if (!session) return <Redirect to="/login" />
  if (requiredRole === 'admin' && userRole !== 'admin') return <Redirect to="/unauthorized" />
  if (allowedBusinessId && userRole !== 'admin' && businessId !== allowedBusinessId) {
    return <Redirect to="/unauthorized" />
  }
  return <>{children}</>
}
```

**Create `src/pages/unauthorized.tsx`:**

Simple 403 page:
- "Unauthorized" heading
- "You don't have permission to access this page" message
- Link back to home or appropriate redirect based on role
- Chester branding (optional - simple is fine for now)

```typescript
export function UnauthorizedPage() {
  return (
    <div className="min-h-screen flex items-center justify-center">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">Unauthorized</h1>
        <p className="text-muted-foreground mb-4">
          You don't have permission to access this page.
        </p>
        <a href="/" className="text-primary hover:underline">
          Return to home
        </a>
      </div>
    </div>
  )
}
```
  </action>
  <verify>
- ProtectedRoute exports correctly
- UnauthorizedPage exports correctly
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
- ProtectedRoute guards routes by auth state and role
- UnauthorizedPage provides user feedback on 403
  </done>
</task>

<task type="auto">
  <name>Task 2: Update App.tsx with auth protection</name>
  <files>src/App.tsx</files>
  <action>
Update `src/App.tsx` to:

1. **Wrap app in AuthProvider**:
```typescript
import { AuthProvider } from '@/contexts/auth-context'
// ... in render:
<AuthProvider>
  <QueryClientProvider client={queryClient}>
    {/* ... rest */}
  </QueryClientProvider>
</AuthProvider>
```

2. **Add new routes**:
- `/login` -> LoginPage (public)
- `/unauthorized` -> UnauthorizedPage (public)

3. **Protect existing routes**:

**Admin-only routes** (wrap with `<ProtectedRoute requiredRole="admin">`):
- `/` (HomePage - lists all businesses)
- `/portfolio` (PortfolioPage - aggregated view)
- `/compare` (ComparePage - compare businesses)

**Business-scoped routes** (check businessId from URL):
- `/business/:businessId` -> ProtectedRoute with allowedBusinessId
- `/business/:businessId/charts` -> ProtectedRoute with allowedBusinessId
- `/business/:businessId/scorecard` -> ProtectedRoute with allowedBusinessId
- `/business/:businessId/scorecard/:scorecardId` -> ProtectedRoute with allowedBusinessId

**Public routes** (no protection):
- `/login`
- `/unauthorized`
- `/submit/:token` (magic link submission)
- `/submit/:token/success`

**Route structure:**
```typescript
<Switch>
  {/* Public */}
  <Route path="/login" component={LoginPage} />
  <Route path="/unauthorized" component={UnauthorizedPage} />
  <Route path="/submit/:token" component={CompanySubmitPage} />
  <Route path="/submit/:token/success" component={SubmissionSuccessPage} />

  {/* Admin only */}
  <Route path="/">
    <ProtectedRoute requiredRole="admin">
      <HomePage />
    </ProtectedRoute>
  </Route>
  <Route path="/portfolio">
    <ProtectedRoute requiredRole="admin">
      <PortfolioPage />
    </ProtectedRoute>
  </Route>
  <Route path="/compare">
    <ProtectedRoute requiredRole="admin">
      <ComparePage />
    </ProtectedRoute>
  </Route>

  {/* Business-scoped */}
  <Route path="/business/:businessId">
    {(params) => (
      <ProtectedRoute allowedBusinessId={params.businessId}>
        <HistoryPage />
      </ProtectedRoute>
    )}
  </Route>
  {/* Similar for other business routes */}

  {/* 404 */}
  <Route>
    <div className="p-8"><h1>404 - Not Found</h1></div>
  </Route>
</Switch>
```

4. **Add logout button to header** (optional, can be added to individual pages or a shared header component later)
  </action>
  <verify>
- App wraps in AuthProvider
- Public routes accessible without login
- Admin routes redirect to /login if unauthenticated
- Business routes check businessId match
- TypeScript compiles: `npx tsc --noEmit`
  </verify>
  <done>
- All routes properly protected based on role requirements
- AuthProvider wraps entire app
- Login and unauthorized pages accessible
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RLS policies migration</name>
  <files>supabase/migrations/20260202_add_rls_policies.sql</files>
  <action>
Create a new migration file that replaces the permissive `USING (true)` policies with role-based policies.

**Important:** Drop existing policies first, then create new ones.

```sql
-- ============================================
-- RLS POLICIES - Replace permissive policies
-- ============================================

-- BUSINESSES: Admins see all, business users see only their own
DROP POLICY IF EXISTS "Allow all access to businesses" ON businesses;
CREATE POLICY "Admin can view all businesses" ON businesses
  FOR SELECT USING (auth.is_admin());
CREATE POLICY "Business user can view own business" ON businesses
  FOR SELECT USING (id = auth.business_id());
CREATE POLICY "Admin can manage businesses" ON businesses
  FOR ALL USING (auth.is_admin());

-- SCORECARDS: Admins see all, business users see only their business
DROP POLICY IF EXISTS "Allow all access to scorecards" ON scorecards;
CREATE POLICY "Admin can view all scorecards" ON scorecards
  FOR SELECT USING (auth.is_admin());
CREATE POLICY "Business user can view own scorecards" ON scorecards
  FOR SELECT USING (business_id = auth.business_id());
CREATE POLICY "Admin can manage all scorecards" ON scorecards
  FOR ALL USING (auth.is_admin());
CREATE POLICY "Business user can insert own scorecards" ON scorecards
  FOR INSERT WITH CHECK (business_id = auth.business_id());

-- DATA_REQUESTS: Admins manage all, business users see their own
DROP POLICY IF EXISTS "Allow all access to data_requests" ON data_requests;
CREATE POLICY "Admin can manage data_requests" ON data_requests
  FOR ALL USING (auth.is_admin());
CREATE POLICY "Business user can view own data_requests" ON data_requests
  FOR SELECT USING (business_id = auth.business_id());

-- COMPANY_SUBMISSIONS: Keep accessible for magic link flow
-- Token validation happens in app, RLS allows anon insert
DROP POLICY IF EXISTS "Allow all access to company_submissions" ON company_submissions;
CREATE POLICY "Anyone can insert submissions" ON company_submissions
  FOR INSERT WITH CHECK (true);  -- Token validated in app
CREATE POLICY "Admin can view all submissions" ON company_submissions
  FOR SELECT USING (auth.is_admin());
CREATE POLICY "Business user can view own submissions" ON company_submissions
  FOR SELECT USING (
    data_request_id IN (
      SELECT id FROM data_requests WHERE business_id = auth.business_id()
    )
  );

-- SECTORS: Public read, admin write
DROP POLICY IF EXISTS "Allow all access to sectors" ON sectors;
CREATE POLICY "Anyone can view sectors" ON sectors
  FOR SELECT USING (true);
CREATE POLICY "Admin can manage sectors" ON sectors
  FOR ALL USING (auth.is_admin());
```

**Note:** The `auth.is_admin()` and `auth.business_id()` functions were created in 02-01-PLAN.md.
  </action>
  <verify>
- Migration syntax is valid (test in Supabase SQL Editor)
- No duplicate policy names
- All existing permissive policies replaced
  </verify>
  <done>
- RLS policies enforce admin-only access to all businesses
- RLS policies restrict business users to their own data
- Magic link submission flow preserved (anon can insert)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete authentication system: login, route protection, and RLS policies</what-built>
  <how-to-verify>
**Test login flow:**
1. Start dev server: `npm run dev`
2. Navigate to `http://localhost:5173/`
3. Should redirect to `/login` (not authenticated)
4. Log in with admin credentials created in 02-01-PLAN.md
5. Should redirect to home page showing all businesses

**Test role-based access:**
1. As admin: Navigate to `/`, `/portfolio`, `/compare` - all should work
2. As admin: Navigate to `/business/{any-id}` - should work (admins see all)
3. Log out (need to implement or clear session in DevTools)

**Test RLS (in Supabase Dashboard):**
1. SQL Editor: `SELECT * FROM businesses;` - should return all (service role)
2. Create a business_user account linked to one business
3. Log in as that user via the app
4. Try to access another business's data - should be blocked

**Expected behaviors:**
- Unauthenticated: Always redirected to /login
- Admin: Can access everything
- Business user: Can only access their own business pages and data
- Magic link submission: Still works for company data entry
  </how-to-verify>
  <resume-signal>Type "auth verified" when login, route protection, and RLS work correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Login page accessible at `/login`
2. Unauthenticated users redirected to login
3. Admin can access all routes
4. Business user cannot access other businesses
5. RLS policies applied to database
6. Magic link submission flow unbroken
</verification>

<success_criteria>
- AUTH-01: Business can log in with email/password - DONE
- AUTH-02: Multiple users from same business see same data - DONE (via business_id link)
- AUTH-03: Chester admin role views all businesses - DONE
- AUTH-04: Business user restricted to own data - DONE (RLS + route protection)
- AUTH-05: Session persists across refresh - DONE (Supabase handles this)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-03-SUMMARY.md`
</output>
